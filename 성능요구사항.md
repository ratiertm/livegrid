# LiveView Grid 성능 요구사항

> **버전**: v0.1.0  
> **작성일**: 2026-02-20  
> **상태**: Draft - 목표 설정

---

## 📋 목차

1. [개요](#개요)
2. [렌더링 성능](#렌더링-성능)
3. [메모리 사용량](#메모리-사용량)
4. [네트워크 성능](#네트워크-성능)
5. [브라우저 호환성](#브라우저-호환성)
6. [동시 사용자](#동시-사용자)
7. [벤치마크 방법](#벤치마크-방법)
8. [경쟁사 비교](#경쟁사-비교)

---

## 개요

LiveView Grid는 **엔터프라이즈급 성능**을 목표로 합니다.

**성능 철학:**
1. **체감 성능 우선** - 사용자가 느끼는 속도가 가장 중요
2. **점진적 개선** - v0.1부터 측정 → v1.0까지 지속 최적화
3. **실제 시나리오 테스트** - 벤치마크보다 실제 사용 패턴 중시
4. **투명한 제한사항** - 성능 한계를 명확히 문서화

---

## 렌더링 성능

### 1. 초기 렌더링

**목표:**

| 데이터 크기 | 목표 시간 | v0.1 목표 | v1.0 목표 |
|-------------|-----------|-----------|-----------|
| 100행 | < 50ms | < 100ms | < 50ms |
| 1,000행 | < 200ms | < 500ms | < 200ms |
| 10,000행 | < 1,000ms | N/A (Virtual Scroll) | < 500ms |
| 100,000행 | < 2,000ms | N/A | < 1,000ms |

**측정 방법:**
```elixir
# Elixir 서버 렌더링 시간
:timer.tc(fn ->
  LiveViewGrid.render(assigns)
end)
```

**참고:**
- 초기 렌더링은 서버 → 클라이언트 전송 시간 포함
- v0.3부터 Virtual Scrolling 도입 시 대용량 데이터 성능 개선 예상

---

### 2. 정렬 성능

**목표:**

| 데이터 크기 | 목표 시간 | v0.1 목표 | v1.0 목표 |
|-------------|-----------|-----------|-----------|
| 100행 | < 10ms | < 20ms | < 10ms |
| 1,000행 | < 50ms | < 100ms | < 50ms |
| 10,000행 | < 300ms | < 500ms | < 200ms |
| 100,000행 | < 1,500ms | N/A | < 500ms |

**측정 방법:**
```elixir
# Enum.sort_by 성능
data = generate_test_data(10_000)

:timer.tc(fn ->
  Enum.sort_by(data, & &1.name)
end)
```

**최적화 전략:**
- v0.1: Elixir `Enum.sort_by` 사용
- v0.2: 정렬 결과 캐싱 (같은 필드 재정렬 시)
- v0.3: 대용량 데이터는 데이터베이스 쿼리로 위임

---

### 3. 필터링 성능

**목표:**

| 데이터 크기 | 목표 시간 | v0.1 목표 | v1.0 목표 |
|-------------|-----------|-----------|-----------|
| 100행 | < 5ms | < 10ms | < 5ms |
| 1,000행 | < 30ms | < 100ms | < 30ms |
| 10,000행 | < 200ms | < 500ms | < 100ms |
| 100,000행 | < 1,000ms | N/A | < 300ms |

**디바운싱:** 300ms (사용자 입력 후 대기 시간)

**측정 방법:**
```elixir
# Enum.filter 성능
data = generate_test_data(10_000)

:timer.tc(fn ->
  Enum.filter(data, fn row ->
    String.contains?(String.downcase(row.name), "alice")
  end)
end)
```

**최적화 전략:**
- v0.1: `Enum.filter` + 디바운싱
- v0.2: 인덱싱 (자주 필터되는 필드)
- v0.3: 데이터베이스 쿼리로 위임

---

### 4. 페이지 전환 성능

**목표:**

| 동작 | 목표 시간 | v0.1 목표 | v1.0 목표 |
|------|-----------|-----------|-----------|
| 다음 페이지 | < 50ms | < 100ms | < 50ms |
| 특정 페이지 점프 | < 100ms | < 200ms | < 100ms |

**측정 방법:**
```elixir
# Enum.slice 성능
data = generate_test_data(10_000)

:timer.tc(fn ->
  Enum.slice(data, 20, 20)  # 2페이지 (page_size=20)
end)
```

---

### 5. 셀 편집 반응 속도

**목표:**

| 동작 | 목표 시간 |
|------|-----------|
| 편집 모드 진입 | < 50ms |
| 입력 반응 (키 입력) | < 16ms (60fps) |
| 편집 완료 (저장) | < 200ms |

**측정 방법:**
- 클라이언트 JavaScript 이벤트 → 서버 응답 → DOM 업데이트

---

## 메모리 사용량

### 서버 메모리 (Elixir BEAM)

**목표:**

| 데이터 크기 | assigns 메모리 | v0.1 목표 | v1.0 목표 |
|-------------|---------------|-----------|-----------|
| 100행 | < 100KB | < 200KB | < 100KB |
| 1,000행 | < 1MB | < 3MB | < 1MB |
| 10,000행 | < 10MB | < 30MB | < 10MB |
| 100,000행 | < 100MB | N/A | < 50MB |

**측정 방법:**
```elixir
# assigns 메모리 측정
assigns = %{grid: LiveViewGrid.new(...)}

:erlang.term_to_binary(assigns) |> byte_size()
```

**주의사항:**
- LiveView는 각 클라이언트마다 별도 프로세스
- 1000명 동시 사용자 × 10MB = 10GB 메모리 필요
- Virtual Scrolling으로 메모리 최적화 필수 (v0.3)

---

### 클라이언트 메모리 (브라우저)

**목표:**

| 데이터 크기 | DOM 크기 | v0.1 목표 | v1.0 목표 |
|-------------|----------|-----------|-----------|
| 100행 | < 5MB | < 10MB | < 5MB |
| 1,000행 | < 50MB | < 100MB | < 30MB |
| 10,000행 | Virtual Scroll | N/A | < 100MB |

**측정 방법:**
- Chrome DevTools → Memory → Heap Snapshot

---

## 네트워크 성능

### 1. 초기 페이지 로드

**목표:**

| 항목 | 목표 크기 | v0.1 목표 | v1.0 목표 |
|------|-----------|-----------|-----------|
| HTML (100행) | < 50KB | < 100KB | < 50KB |
| HTML (1,000행) | < 500KB | < 1MB | < 300KB |
| CSS | < 20KB | < 50KB | < 20KB |
| JavaScript | < 50KB | < 100KB | < 50KB |

**압축:** Gzip/Brotli 적용 (Phoenix 기본)

---

### 2. WebSocket 메시지 크기

**목표:**

| 이벤트 | 페이로드 크기 | v0.1 목표 | v1.0 목표 |
|--------|--------------|-----------|-----------|
| 정렬 | < 1KB | < 5KB | < 1KB |
| 필터 | < 2KB | < 10KB | < 2KB |
| 페이지 변경 | < 1KB | < 5KB | < 1KB |
| 셀 편집 | < 500B | < 2KB | < 500B |

**측정 방법:**
- Chrome DevTools → Network → WS (WebSocket 탭)

---

### 3. 리렌더링 전송량

**목표:**

| 변경 범위 | 전송량 | v0.1 목표 | v1.0 목표 |
|-----------|--------|-----------|-----------|
| 단일 셀 | < 500B | < 2KB | < 500B |
| 단일 행 | < 2KB | < 10KB | < 2KB |
| 전체 그리드 | < 100KB | < 500KB | < 100KB |

**LiveView Diff 최적화:**
- LiveView는 변경된 부분만 전송 (자동)
- 불필요한 상태 변경 최소화

---

## 브라우저 호환성

### 지원 브라우저

| 브라우저 | 최소 버전 | 목표 |
|----------|-----------|------|
| Chrome | 90+ | ✅ Full Support |
| Firefox | 88+ | ✅ Full Support |
| Safari | 14+ | ✅ Full Support |
| Edge | 90+ | ✅ Full Support |
| Mobile Safari (iOS) | 14+ | ⚠️ Limited (v0.3) |
| Chrome Mobile (Android) | 90+ | ⚠️ Limited (v0.3) |

**IE11:** ❌ Not Supported (Phoenix LiveView 비호환)

---

### 성능 목표 (브라우저별)

**Desktop (1920x1080, Core i5, 8GB RAM):**
- 초기 렌더링 (1,000행): < 200ms
- 60fps 스크롤
- 메모리 < 100MB

**Mobile (iPhone 12):**
- 초기 렌더링 (1,000행): < 500ms
- 30fps 스크롤
- 메모리 < 50MB

---

## 동시 사용자

### 서버 부하

**목표 (단일 서버 기준):**

| 동시 사용자 | CPU 사용률 | 메모리 | v0.1 목표 | v1.0 목표 |
|-------------|-----------|--------|-----------|-----------|
| 10명 | < 10% | < 500MB | ✅ | ✅ |
| 100명 | < 30% | < 3GB | ⚠️ | ✅ |
| 1,000명 | < 70% | < 20GB | ❌ | ⚠️ |
| 10,000명 | Cluster | Cluster | ❌ | ⚠️ |

**서버 스펙 (예상):**
- CPU: 4 cores
- RAM: 16GB
- Network: 1Gbps

**스케일링 전략:**
- v0.1: 단일 서버 (10~100명)
- v0.3: Elixir Clustering (1,000명)
- v1.0: 로드 밸런서 + 다중 노드 (10,000명+)

---

### WebSocket 연결

**목표:**

| 항목 | 목표 |
|------|------|
| 연결 유지 시간 | > 1시간 |
| 재연결 시간 | < 1초 |
| 메시지 손실 | 0% |

**Phoenix Channels 기본 제공:**
- 자동 재연결
- Heartbeat (30초)

---

## 벤치마크 방법

### 1. 렌더링 벤치마크

```elixir
# test/performance/rendering_benchmark.exs
defmodule LiveViewGrid.RenderingBenchmark do
  use ExUnit.Case
  
  @data_sizes [100, 1_000, 10_000]
  
  for size <- @data_sizes do
    @tag :benchmark
    test "렌더링 성능: #{size}행" do
      data = generate_test_data(unquote(size))
      grid = LiveViewGrid.new(data: data, columns: test_columns())
      
      {time_us, _result} = :timer.tc(fn ->
        LiveViewGrid.render(grid)
      end)
      
      time_ms = time_us / 1_000
      IO.puts("#{unquote(size)}행 렌더링: #{time_ms}ms")
      
      # 목표 시간 검증
      target_ms = case unquote(size) do
        100 -> 100
        1_000 -> 500
        10_000 -> 5_000
      end
      
      assert time_ms < target_ms, "너무 느림: #{time_ms}ms > #{target_ms}ms"
    end
  end
end
```

실행:
```bash
mix test --only benchmark
```

---

### 2. 메모리 벤치마크

```elixir
# test/performance/memory_benchmark.exs
defmodule LiveViewGrid.MemoryBenchmark do
  use ExUnit.Case
  
  @tag :benchmark
  test "메모리 사용량: 1,000행" do
    data = generate_test_data(1_000)
    grid = LiveViewGrid.new(data: data, columns: test_columns())
    
    # assigns 직렬화 크기
    assigns = %{grid: grid}
    size_bytes = :erlang.term_to_binary(assigns) |> byte_size()
    size_mb = size_bytes / 1_024 / 1_024
    
    IO.puts("assigns 메모리: #{size_mb} MB")
    
    # 목표: < 3MB
    assert size_mb < 3.0, "메모리 초과: #{size_mb}MB > 3MB"
  end
end
```

---

### 3. E2E 성능 테스트 (Wallaby)

```elixir
# test/performance/e2e_benchmark.exs
defmodule LiveViewGrid.E2EBenchmark do
  use MyAppWeb.ConnCase
  use Wallaby.Feature
  
  @tag :benchmark
  feature "초기 로드 성능", %{session: session} do
    # 1,000행 데이터 준비
    insert_list(1_000, :user)
    
    # 페이지 로드 시작
    start_time = System.monotonic_time(:millisecond)
    
    session
    |> visit("/users")
    |> assert_has(css(".grid-container"))
    
    # 로드 완료 시간
    end_time = System.monotonic_time(:millisecond)
    load_time = end_time - start_time
    
    IO.puts("초기 로드 시간: #{load_time}ms")
    
    # 목표: < 2초
    assert load_time < 2_000, "너무 느림: #{load_time}ms"
  end
end
```

---

## 경쟁사 비교

### 목표: 상위 3개 제품과 동등 이상

| 제품 | 초기 렌더링 (1,000행) | 정렬 | 필터 | 라이선스 |
|------|----------------------|------|------|---------|
| **AG Grid** | 150ms | 80ms | 100ms | Enterprise |
| **DevExpress** | 200ms | 120ms | 150ms | Commercial |
| **Toast UI Grid** | 180ms | 100ms | 120ms | MIT |
| **LiveView Grid (목표)** | **< 200ms** | **< 100ms** | **< 100ms** | **MIT/Commercial** |

**차별점:**
- ✅ **서버 사이드 렌더링** - SEO 친화적
- ✅ **WebSocket 실시간 동기화** - 다중 사용자 협업
- ✅ **Elixir 동시성** - 대규모 트래픽 처리
- ⚠️ **초기 로드 느림** - 서버 렌더링 트레이드오프

---

## 성능 모니터링 (프로덕션)

### 1. LiveView Telemetry

```elixir
# lib/my_app_web/telemetry.ex
defmodule MyAppWeb.Telemetry do
  def handle_event([:phoenix, :live_view, :mount, :start], _measurements, metadata, _) do
    # Grid mount 시작 시간 기록
  end
  
  def handle_event([:phoenix, :live_view, :mount, :stop], measurements, metadata, _) do
    # Grid mount 소요 시간 로깅
    duration_ms = System.convert_time_unit(measurements.duration, :native, :millisecond)
    Logger.info("LiveView mount: #{duration_ms}ms")
  end
end
```

---

### 2. 성능 대시보드 (LiveDashboard)

```elixir
# config/dev.exs
config :my_app, MyAppWeb.Endpoint,
  live_view: [signing_salt: "..."],
  debug_errors: true,
  code_reloader: true,
  check_origin: false,
  watchers: []

# lib/my_app_web/router.ex
import Phoenix.LiveDashboard.Router

scope "/" do
  pipe_through :browser
  live_dashboard "/dashboard", metrics: MyAppWeb.Telemetry
end
```

**모니터링 항목:**
- LiveView 프로세스 수
- 메모리 사용량 (per process)
- WebSocket 연결 수
- 평균 응답 시간

---

## 성능 최적화 로드맵

### v0.1 (현재)
- [x] 기본 렌더링 구현
- [ ] 벤치마크 테스트 작성
- [ ] 목표 성능 측정

### v0.2
- [ ] 정렬/필터 최적화 (캐싱)
- [ ] 디바운싱 적용
- [ ] 메모리 프로파일링

### v0.3
- [ ] Virtual Scrolling 구현
- [ ] 대용량 데이터 최적화
- [ ] 데이터베이스 쿼리 위임

### v1.0
- [ ] 경쟁사 수준 성능 달성
- [ ] 프로덕션 모니터링 구축
- [ ] 성능 가이드 문서화

---

## 버전 이력

| 버전 | 날짜 | 변경사항 |
|------|------|----------|
| v0.1.0 | 2026-02-20 | 초안 작성 |

---

## 다음 단계

- [ ] 벤치마크 테스트 실행
- [ ] 실제 성능 측정 및 갭 분석
- [ ] 최적화 우선순위 결정

🐾
