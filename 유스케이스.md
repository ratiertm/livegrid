# LiveView Grid 유스케이스

> **버전**: v0.1.0  
> **작성일**: 2026-02-20  
> **상태**: Draft - 사용자 시나리오 정의

---

## 📋 목차

1. [액터 정의](#액터-정의)
2. [v0.1 유스케이스](#v01-유스케이스)
3. [v0.2 유스케이스](#v02-유스케이스)
4. [v0.3 유스케이스](#v03-유스케이스)
5. [예외 시나리오](#예외-시나리오)

---

## 액터 정의

### Primary Actors (주요 액터)

#### 1. 최종 사용자 (End User)
- **역할:** Grid를 통해 데이터를 조회/편집
- **목표:** 빠르고 직관적으로 데이터 탐색
- **기술 수준:** 일반 사용자 (IT 전문가 아님)

#### 2. 개발자 (Developer)
- **역할:** LiveView Grid를 자신의 앱에 통합
- **목표:** 최소한의 코드로 그리드 구현
- **기술 수준:** Elixir/Phoenix 경험자

### Secondary Actors (부가 액터)

#### 3. 시스템 관리자 (Admin)
- **역할:** 대용량 데이터 모니터링
- **목표:** 성능 지표 확인 및 최적화

---

## v0.1 유스케이스

### UC-001: 데이터 목록 조회

**액터:** 최종 사용자  
**목표:** 사용자 목록을 그리드로 확인  
**사전 조건:** 사용자가 `/users` 페이지에 접속  
**사후 조건:** 사용자 목록이 테이블 형태로 표시됨

#### 주요 흐름

1. 사용자가 `/users` URL에 접속
2. LiveView가 `mount/3` 실행
3. `Users.list_users/0`로 데이터 조회
4. `LiveViewGrid.new/1`로 Grid 초기화
5. 사용자 목록이 테이블로 렌더링
6. 20개 행씩 페이지네이션으로 표시

#### 예시 코드

```elixir
defmodule MyAppWeb.UserLive.Index do
  use MyAppWeb, :live_view
  alias LiveViewGrid
  alias MyApp.Users

  def mount(_params, _session, socket) do
    users = Users.list_users()
    
    grid = LiveViewGrid.new(
      data: users,
      columns: [
        %{field: :id, label: "ID", width: 80},
        %{field: :name, label: "이름", width: 150, sortable: true},
        %{field: :email, label: "이메일", width: 200},
        %{field: :created_at, label: "가입일", width: 120}
      ],
      options: %{page_size: 20}
    )
    
    {:ok, assign(socket, grid: grid)}
  end
end
```

#### 화면

```
┌────────────────────────────────────────────┐
│ 사용자 목록                                │
├────┬─────────────┬───────────────┬─────────┤
│ ID │ 이름        │ 이메일         │ 가입일  │
├────┼─────────────┼───────────────┼─────────┤
│ 1  │ Alice       │ alice@...     │ 2024-01 │
│ 2  │ Bob         │ bob@...       │ 2024-02 │
│ ...│ ...         │ ...           │ ...     │
├────┴─────────────┴───────────────┴─────────┤
│ [<] 1 2 3 ... 10 [>]     총 197명          │
└────────────────────────────────────────────┘
```

---

### UC-002: 컬럼 정렬

**액터:** 최종 사용자  
**목표:** 이름순으로 사용자 목록 정렬  
**사전 조건:** UC-001 완료 (그리드 표시 중)  
**사후 조건:** 선택한 컬럼 기준으로 정렬됨

#### 주요 흐름

1. 사용자가 "이름" 컬럼 헤더 클릭
2. `phx-click="grid_sort"` 이벤트 발생
3. 서버가 `handle_event("grid_sort", ...)` 처리
4. `Enum.sort_by(data, :name)` 실행
5. assigns 업데이트
6. Grid 리렌더링 (오름차순, ▲ 아이콘 표시)

#### 대체 흐름 (토글)

7. 사용자가 "이름" 컬럼 헤더 재클릭
8. 내림차순으로 정렬 (▼ 아이콘)
9. 3번째 클릭 시 정렬 해제 (원래 순서)

#### 예시 코드

```elixir
def handle_event("grid_sort", %{"field" => field, "direction" => direction}, socket) do
  grid = socket.assigns.grid
  
  sorted_data = case direction do
    "asc" -> Enum.sort_by(grid.data, &Map.get(&1, String.to_atom(field)))
    "desc" -> Enum.sort_by(grid.data, &Map.get(&1, String.to_atom(field)), :desc)
  end
  
  updated_grid = %{grid | 
    data: sorted_data,
    state: %{grid.state | sort: %{field: field, direction: direction}}
  }
  
  {:noreply, assign(socket, grid: updated_grid)}
end
```

#### 화면 변화

**정렬 전:**
```
┌────┬─────────────┬──────────────┐
│ ID │ 이름        │ 이메일        │
├────┼─────────────┼──────────────┤
│ 2  │ Bob         │ bob@...      │
│ 1  │ Alice       │ alice@...    │
│ 3  │ Charlie     │ charlie@...  │
└────┴─────────────┴──────────────┘
```

**정렬 후 (이름 오름차순):**
```
┌────┬──────────────▲─┬──────────────┐
│ ID │ 이름           │ 이메일        │
├────┼───────────────┼──────────────┤
│ 1  │ Alice         │ alice@...    │
│ 2  │ Bob           │ bob@...      │
│ 3  │ Charlie       │ charlie@...  │
└────┴───────────────┴──────────────┘
```

---

### UC-003: 페이지 이동

**액터:** 최종 사용자  
**목표:** 다음 페이지 사용자 목록 보기  
**사전 조건:** 전체 데이터가 20개 이상  
**사후 조건:** 다음 20개 행이 표시됨

#### 주요 흐름

1. 사용자가 "2" 페이지 버튼 클릭
2. `phx-click="grid_page_change"` 이벤트 발생
3. 서버가 현재 페이지를 2로 업데이트
4. `Enum.slice(data, 20, 20)` 실행 (2페이지 데이터)
5. Grid 리렌더링

#### 예시 코드

```elixir
def handle_event("grid_page_change", %{"page" => page}, socket) do
  grid = socket.assigns.grid
  page_num = String.to_integer(page)
  
  start_index = (page_num - 1) * grid.options.page_size
  page_data = Enum.slice(grid.data, start_index, grid.options.page_size)
  
  updated_grid = %{grid |
    state: %{grid.state | 
      pagination: %{grid.state.pagination | current_page: page_num}
    }
  }
  
  {:noreply, assign(socket, grid: updated_grid)}
end
```

#### 화면

```
┌────────────────────────────────────────┐
│ [<] [1] 2 3 ... 10 [>]   총 197명      │ ← 1페이지
└────────────────────────────────────────┘

(클릭 후)

┌────────────────────────────────────────┐
│ [<] 1 [2] 3 ... 10 [>]   총 197명      │ ← 2페이지
└────────────────────────────────────────┘
```

---

### UC-004: 행 선택

**액터:** 최종 사용자  
**목표:** 특정 사용자 선택하여 상세 정보 확인  
**사전 조건:** 그리드에 데이터 표시 중  
**사후 조건:** 선택된 행이 하이라이트됨

#### 주요 흐름

1. 사용자가 "Alice" 행 클릭
2. `phx-click="grid_row_select"` 이벤트 발생
3. 서버가 `selected_ids` 업데이트 (`[1]`)
4. CSS 클래스 `.selected` 추가
5. 행 배경색 변경 (#e3f2fd)

#### 예시 코드

```elixir
def handle_event("grid_row_select", %{"row_id" => row_id}, socket) do
  grid = socket.assigns.grid
  id = String.to_integer(row_id)
  
  updated_selection = %{grid.state.selection | selected_ids: [id]}
  updated_grid = %{grid | state: %{grid.state | selection: updated_selection}}
  
  {:noreply, assign(socket, grid: updated_grid)}
end
```

#### 화면

```
┌────┬─────────────┬──────────────┐
│ ID │ 이름        │ 이메일        │
├────┼─────────────┼──────────────┤
│ 1  │ Alice       │ alice@...    │ ← 클릭
│ 2  │ Bob         │ bob@...      │
└────┴─────────────┴──────────────┘

(클릭 후)

┌────┬─────────────┬──────────────┐
│ ID │ 이름        │ 이메일        │
├────┼─────────────┼──────────────┤
│ 1  │ Alice       │ alice@...    │ ← 파란 배경
│ 2  │ Bob         │ bob@...      │
└────┴─────────────┴──────────────┘
```

---

### UC-005: Grid 통합 (개발자)

**액터:** 개발자  
**목표:** LiveView에 Grid 추가  
**사전 조건:** Phoenix 프로젝트 존재  
**사후 조건:** 동작하는 Grid 페이지

#### 주요 흐름

1. 개발자가 `mix.exs`에 의존성 추가
```elixir
{:liveview_grid, "~> 0.1"}
```

2. LiveView 모듈 생성
```elixir
defmodule MyAppWeb.UserLive.Index do
  use MyAppWeb, :live_view
  alias LiveViewGrid

  def mount(_params, _session, socket) do
    grid = LiveViewGrid.new(
      data: MyApp.Users.list_users(),
      columns: [
        %{field: :name, label: "이름", sortable: true}
      ]
    )
    
    {:ok, assign(socket, grid: grid)}
  end
  
  def handle_event("grid_sort", params, socket) do
    # 정렬 로직
  end
end
```

3. 템플릿 추가
```heex
<LiveViewGrid.render grid={@grid} />
```

4. 라우터 설정
```elixir
live "/users", UserLive.Index
```

5. `mix phx.server` 실행
6. `/users` 접속하여 확인

**소요 시간:** < 10분 (문서 참고 시)

---

## v0.2 유스케이스

### UC-101: 전체 검색

**액터:** 최종 사용자  
**목표:** "Alice"라는 이름이 포함된 사용자 찾기  
**사전 조건:** 그리드에 100명의 사용자 표시 중  
**사후 조건:** 필터링된 결과만 표시

#### 주요 흐름

1. 사용자가 검색창에 "Alice" 입력
2. 300ms 디바운싱 대기
3. `phx-change="grid_search"` 이벤트 발생
4. 서버가 모든 컬럼에서 검색
```elixir
Enum.filter(data, fn row ->
  Enum.any?(row, fn {_k, v} ->
    String.contains?(String.downcase(to_string(v)), "alice")
  end)
end)
```
5. 결과 3건 표시

#### 화면

```
┌────────────────────────────────────┐
│ 🔍 검색: [Alice___________]       │
└────────────────────────────────────┘
┌────┬─────────────┬──────────────┐
│ ID │ 이름        │ 이메일        │
├────┼─────────────┼──────────────┤
│ 1  │ Alice       │ alice@...    │ ← 검색 결과 1
│ 5  │ Alicia      │ alicia@...   │ ← 검색 결과 2
│ 12 │ Alice Kim   │ akim@...     │ ← 검색 결과 3
└────┴─────────────┴──────────────┘
총 3명 (100명 중)
```

---

### UC-102: 컬럼별 필터

**액터:** 최종 사용자  
**목표:** 나이가 30세 이상인 사용자만 보기  
**사전 조건:** 그리드에 나이 컬럼 존재  
**사후 조건:** 조건에 맞는 사용자만 표시

#### 주요 흐름

1. 사용자가 "나이" 컬럼 헤더 아래 필터 아이콘 클릭
2. 드롭다운에서 "≥ (이상)" 선택
3. 값 입력창에 "30" 입력
4. `phx-change="grid_filter"` 이벤트 발생
5. 서버가 필터 적용
```elixir
Enum.filter(data, fn row -> row.age >= 30 end)
```
6. 결과 15명 표시

#### 화면

```
┌────┬─────────────┬──────┐
│ ID │ 이름        │ 나이 ▼│
│    │             │ ≥ 30  │ ← 필터 설정
├────┼─────────────┼──────┤
│ 1  │ Alice       │ 30   │
│ 3  │ Charlie     │ 35   │
│ 7  │ Eve         │ 42   │
└────┴─────────────┴──────┘
총 15명 (100명 중)
```

---

### UC-103: 다중 행 선택 후 일괄 삭제

**액터:** 최종 사용자  
**목표:** 여러 사용자를 선택하여 삭제  
**사전 조건:** 그리드에 체크박스 컬럼 활성화  
**사후 조건:** 선택된 사용자 삭제됨

#### 주요 흐름

1. 사용자가 체크박스 컬럼에서 3개 행 선택
2. "삭제" 버튼 클릭
3. 확인 다이얼로그 표시
4. "확인" 클릭
5. 서버가 `Users.delete_users(selected_ids)` 실행
6. Grid 데이터 새로고침
7. 성공 메시지 표시

#### 예시 코드

```elixir
def handle_event("delete_selected", _params, socket) do
  grid = socket.assigns.grid
  selected_ids = grid.state.selection.selected_ids
  
  # 데이터베이스 삭제
  Enum.each(selected_ids, &Users.delete_user/1)
  
  # Grid 새로고침
  updated_data = Users.list_users()
  updated_grid = %{grid | data: updated_data}
  
  {:noreply, 
    socket
    |> assign(grid: updated_grid)
    |> put_flash(:info, "#{length(selected_ids)}명이 삭제되었습니다.")
  }
end
```

---

## v0.3 유스케이스

### UC-201: 대용량 데이터 스크롤

**액터:** 최종 사용자  
**목표:** 10,000명의 사용자 목록을 부드럽게 스크롤  
**사전 조건:** Virtual Scrolling 구현됨  
**사후 조건:** 60fps 스크롤 유지

#### 주요 흐름

1. 사용자가 `/users` 접속 (10,000명 데이터)
2. 서버가 처음 100행만 렌더링
3. 사용자가 스크롤 시작
4. JavaScript Hook이 스크롤 위치 감지
5. 80% 도달 시 서버에 다음 100행 요청
6. 서버가 추가 데이터 전송
7. 클라이언트가 DOM 업데이트 (부드러운 스크롤)

#### 성능 목표

- 초기 렌더링: < 500ms
- 스크롤 응답: < 16ms (60fps)
- 메모리: < 100MB

---

## 예외 시나리오

### EX-001: 빈 데이터

**시나리오:** 사용자 목록이 비어있음  
**동작:**
1. 빈 테이블 렌더링
2. "데이터가 없습니다" 메시지 표시
3. 페이징 숨김

```
┌────────────────────────────────────┐
│ ID │ 이름 │ 이메일                │
├────┴──────┴───────────────────────┤
│     데이터가 없습니다.             │
└────────────────────────────────────┘
```

---

### EX-002: 정렬 중 에러

**시나리오:** 정렬 중 서버 에러 발생  
**동작:**
1. 에러 로그 기록
2. 사용자에게 에러 메시지 표시
3. 이전 상태로 롤백

```elixir
def handle_event("grid_sort", params, socket) do
  try do
    # 정렬 로직
  rescue
    e ->
      Logger.error("정렬 실패: #{inspect(e)}")
      {:noreply, put_flash(socket, :error, "정렬 중 오류가 발생했습니다.")}
  end
end
```

---

### EX-003: 검색 결과 없음

**시나리오:** 검색어와 일치하는 데이터가 없음  
**동작:**
1. 빈 테이블 렌더링
2. "검색 결과가 없습니다" 메시지
3. 검색어 표시 ("XYZ"에 대한 검색 결과)

```
┌────────────────────────────────────┐
│ 🔍 검색: [XYZABC___________]      │
└────────────────────────────────────┘
┌────┬──────┬────────────────────────┐
│ ID │ 이름 │ 이메일                  │
├────┴──────┴────────────────────────┤
│  "XYZABC"에 대한 검색 결과가       │
│  없습니다.                         │
└────────────────────────────────────┘
```

---

### EX-004: 느린 네트워크

**시나리오:** WebSocket 연결 지연  
**동작:**
1. 로딩 인디케이터 표시
2. 5초 타임아웃 후 재시도
3. 3회 실패 시 에러 메시지

```
┌────────────────────────────────────┐
│         로딩 중...  ⏳             │
└────────────────────────────────────┘
```

---

### EX-005: 동시 편집 충돌 (v1.0)

**시나리오:** 두 사용자가 같은 셀을 동시에 편집  
**동작:**
1. 먼저 저장한 사용자의 변경사항 적용
2. 늦게 저장한 사용자에게 충돌 경고
3. 최신 값으로 덮어쓸지 선택 제공

```
┌────────────────────────────────────┐
│ ⚠️  다른 사용자가 이 데이터를      │
│     변경했습니다.                  │
│     [ 최신 값 보기 ] [ 덮어쓰기 ] │
└────────────────────────────────────┘
```

---

## 사용자 여정 맵 (User Journey)

### 신규 개발자

```
1. 문서 읽기 (5분)
   ↓
2. 설치 (mix.exs) (1분)
   ↓
3. 기본 코드 복사 (3분)
   ↓
4. 확인 (1분)
   ↓
✅ 총 10분 이내 완성
```

### 최종 사용자

```
1. 페이지 접속
   ↓
2. 데이터 확인 (스크롤)
   ↓
3. 정렬/필터 적용
   ↓
4. 원하는 데이터 찾기
   ↓
5. 행 선택 → 상세 페이지 이동
```

---

## 버전 이력

| 버전 | 날짜 | 변경사항 |
|------|------|----------|
| v0.1.0 | 2026-02-20 | 초안 작성, v0.1~v0.3 유스케이스 |

---

## 다음 단계

- [ ] 화면 디자인 (Wireframe)
- [ ] 프로토타입 개발
- [ ] 사용자 테스트

🐾
